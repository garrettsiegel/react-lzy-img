Audit Findings

High – Cross-platform build scripts (package.json): the build, cleanup-types, and fix-index-types pipeline shells out to rm -rf and find, which fail on Windows or GitHub Actions Windows runners. Replace with portable tools (rimraf, fast-glob, or Node’s fs APIs) so npm publish remains reliable across environments.
High – Hand-written declaration bundle drift (bundle-types.js, index.d.ts): the generated d.ts file is a static template unrelated to the source types, so any prop change (e.g., adding placeholderBlur to LazyImage) won’t be reflected. Prefer emitting declarations directly from tsc or use rollup-plugin-dts/API Extractor so the published types always match the actual API.
Medium – forceVisible/priority state is only read once (LazyImage.tsx lines 18-34): if forceVisible or priority toggles after the first render, isInView never updates because the state is initialised from props and never re-synced. Add an effect that watches those props and updates isInView so imperative consumers can force-load images later.
Medium – LazyImage props don’t extend native <img> attributes (types.ts): unlike LazyPicture, the Props type omits React.ImgHTMLAttributes, preventing legitimate props (decoding, loading, ref, custom aria-*) from type-checking, and the implementation never spreads unknown props to <img>. Consider mirroring LazyPictureProps (extend & omit conflicting keys) and forward the rest to the underlying <img>.
Medium – Fallback styles never ship (injectStyle.ts, LazyImage.css): the runtime CSS injection excludes .LazyImage-fallback, yet LazyImage.css defining it is never imported, so published builds render raw text for fallbacks. Either import the CSS beside the components or add those rules to the injected string.
Low – Duplicate lazy-loading logic (LazyImage.tsx, LazyPicture.tsx, useLazyLoad.ts): both components roll their own IntersectionObserver setup instead of reusing useLazyLoad, which makes behaviours diverge (once, cleanup, SSR fallback). Refactoring to the shared hook would reduce code size and bugs.
Low – useLazyImage timer edge cases (useLazyLoad.ts): the effect ignores placeholderSrc in its dependency list and never clears the timeout, so changing placeholders at runtime or unmounting before the timer fires can lead to stale state or set-state-on-unmounted warnings. Track all inputs and clear timers in the cleanup.
Process – Tooling/testing gaps: the build relies on npm:rolldown-vite@7.2.2, which is still experimental and may emit incompatible bundles; there are no tests or automated visual checks backing the public API claims (only npm run lint/build currently succeed). Consider pinning a stable Vite/Rollup release, adding lightweight component tests or Storybook stories, and verifying the gzipped size claims.
Lint (npm run lint) and build (npm run build) complete successfully with the current codebase. Next steps I’d tackle: 1) make the build/type pipeline portable and source-of-truth driven, 2) fix the forceVisible/props reactivity and prop typing gaps, 3) ensure the shipped CSS matches the documented classes, and 4) add minimal tests/demos to keep regressions in check.